---
layout:     post
title:      Python网络编程模块
subtitle:   null
date:       2019-07-08
author:     LudoArt
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 游戏服务器

---

# Python网络编程模块

## 1.1 Python Socket

### 1.1.1 Socket套接字

**引入一个Socket模块：**

```python
import socket
```

**Python的Socket模块的函数原型：**

```python
socket(family, type[, protocal])
```

其中Socket地址族和Socket类型如下表所示。

| Socket地址族 |   Socket类型   |    协议     |
| :----------: | :------------: | :---------: |
|   AF_INET    |  SOCK_STREAM   | IPPROTO_TCP |
|   AF_INET6   |   SOCK_DGRAM   | IPPROTO_RAW |
|   AF_UNIX    |    SOCK_RAW    |             |
|              | SOCK_SEQPACKET |             |

### 1.1.2 SOCK_STREAM、SOCK_DGRAM

|  参数类型   |                             作用                             |
| :---------: | :----------------------------------------------------------: |
| SOCK_STREAM |           其指定的是数据流Socket，一般指的是TCP/IP           |
| SOCK_DGRAW  | 英文全称是datagrams，即数据报的形式，没有保障的面向消息的Socket，一般指的是UDP |
|  SOCK_RAW   | 指原始套接字编程，可以接收数据帧或者数据包，可以用来监听网络的流量和进行数据包分析 |

**创建Socket：**

```python
s_handle = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

`s_handle` 是Socket模块初始化后返回的对象，初始化的参数是 `AF_INET` 和 `SOCK_STREAM` ，说明初始化的网络参数是TCP协议。第三个参数，可以选择 `IPPROTO_TCP` 或 `IPPROTO_RAW` 来指定所使用的协议，也可以忽略第三个参数。

若第二个参数填的是 `SOCK_RAW` ,在初始化之前，可使用 `getprotobyname` 函数来得到第三个参数指定所使用的协议。如下所示：

```python
protocal = socket.getprotobyname('imcp')
s_handle = socket.socket(socket.AF_INET, socket.SOCK_RAW, protocal)
```

**销毁socket对象：**

```python
s_handle.close()
```

### 1.1.3 阻塞和非阻塞模式

**阻塞模式**指的是在操作系统进行I/O操作完成前，执行的操作函数和内容一直会等待I/O操作完成而不会立刻返回，该函数的执行线程会阻塞在当前函数；

**非阻塞模式**则相反，执行函数将会立即返回而不管I/O操作是否完成，该函数线程会继续往下执行命令。

**设置非阻塞代码的方法：**

- `s_handle.setblocking(Flase)`
- 设置超时时间：`s_handle.settimeout(timeout)`

## 1.2 服务端其他Socket方法

### 1.2.1 bind和listen

在一段网络服务器代码中，开始运作逻辑之前，必须要保证网络地址和端口的绑定。

```python
host = ""
port = 4096
s_handle.bind((host, port)) # 若绑定的地址为0.0.0.0，则绑定本机网卡上所有IP的地址

s_handle.listen(5)
print "start..."
while 1:
	do_something
```

**保证地址和端口的绑定：**

```python
s_handle.bind((host, port))
```

**保证监听所绑定的地址和端口所传来的数据：**

```python
s_handle.listen(5)
```

> Python中listen函数的参数为backlog，即在进程空间维护的请求队列的大小。

### 1.2.2 setsockopt

Python的 `setsockopt` 接受三个参数：`level`、`optname`、`value`。

- `level` 指的是定义的层级，其中包括：
  - SOL_SOCKET：基本套接字接口；
  - IPPROTO_IP：IPV4套接字接口；
  - IPPROTO_IPV6：IPV6套接字接口；
  - IPPROTO_TCP：TCP套接字接口；
- `optname` 指的是选项名称，当 `level` 参数选择不同时，`optname` 的值又会有所不同
- `value` 指的是设置 `optname` 选项的值

示例代码：

```python
s_handle = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s_handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 说明我们需要Socket句柄关闭后能立刻被重用
```

```python
# 将Socket接收和发送内容的缓冲区大小从系统的默认值替换为我们自己定义的值

s_handle.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, SEND_BUF_SIZE)
s_handle.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, RECV_BUF_SIZE)
# 将设置的值取回来

current_buf_size = s_handle.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)
```

> **小结：**
>
> 在服务器代码中，为了保证端口和地址的绑定操作，我们要使用 `bind` 函数来进行操作，如果原始Socket参数不够设置，则应使用 `setsockopt` 函数来设置更多的内容。



## 1.3 客户端Socket

### 1.3.1 connect方法

```python
import socket
s_handle = socket.socket(socket.AF_INET, socket.SOCK_STERAM)
s_handle.connect(("www.msn.com", 80))
```

`connect` 接收一个 `tuple` 参数，分别为地址和端口，如果连接出错，则返回一个Socket error。

> `connect`的另一个版本`connect_ex`，传入的参数也是接收一个`tuple`，但返回值不同，它返回的是一个C层级的返回值。
>
> - 如果连接成功，返回一个0
> - 如果连接失败，返回一个Socket系列的error错误号（如10060）或抛出一个异常（如host not found，11001异常等）

当不知道需要连接的服务器的默认端口号是什么，可以通过`getservbyname`函数来获得，如下：

```python
import socket
s_handle = sokcet.socket(socket.AF_INET, socket.SOCK_STERAM)
port = socket.getservbyname('http', 'tcp') # 查询所需要的服务名称和协议获取端口号
s_handle.connect(('www.msn.com', port))
```

查询主机地址可以使用函数`gethostbyname`，而`gethostbyname_ex`除了查询主机的IP和名称外，还有主机名列表和主机IP地址类别等信息：`socket.gethostbyname_ex('www.microsoft.com')`

## 1.4 通用的Socket方法

### 1.4.1 recv和send

`recv`和`send`两个函数是供TCP协议编程时使用的发送和接收函数。

**`recv`的Python原型：** `recv(bufsize[, flags])`

`recv`函数接收Socket传过来的内容，其中`bufsize`为字符串缓冲区大小，返回的是字符串，而`flag`则是指定有关消息的其他值，具体可以通过UNIX的manual手册的recv(2)查询，其中包含：MSG_NOWAIT、MSG_ERRQUEUE、MSG_OOB、MSG_PEEK等参数。

**`send`的Python原型：**`send(string[, flags])`

`send`函数接收一串待发送的字符串，返回被发送后的字节数，根据发送字节数的多少，该字节数有可能小于string字符串数量。

`sendall(string[, flags])`函数保证一次性将字符串全部传完，如果出错，将抛出一个异常。

### 1.4.2 recvfrom和sendto

`recvfrom`和`sendto`函数主要应用于UDP这样面向无连接的网络编程模型，也可用于TCP编程中。

**其在Python中的函数原型：**

`recvfrom(bufsize[, flags])`，string是接收到的内容，address是发送端Socket的地址；

`sendto(string, address)`

`sendto(string, flags, address)`，其中flags和`recv`中的flags相同。

代码示例：

```python
import socket, sys
addr = (`<broadcast>`, 2233) # broadcast标明这是广播的代码
s_handle = socket.socket(socket.AF_INET, socket.SOCK_DGRAW)
s_handle.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
while True:
    data = s_handle.recvfrom(1024)
    if data:
        s_handle.sendto("my message", addr)
    s_handle.close()
```

>**小结：**
>
>`recv`和`send`，`recvfrom`和`sendto`是通用的Socket方法，这些方法是组成基础Socket代码所必须使用的，包括客户端和服务器端，在UDP中，由于目标地址并不明确，所以要选择`recvfrom`和`sendto`方法，当然TCP也可以用，只是多此一举。

## 1.5 SimpleHTTPServer和BaseHTTPServer

### 1.5.1 SimpleHTTPServer



